"use strict";(self.webpackChunkckb_sdk=self.webpackChunkckb_sdk||[]).push([[2782],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>u});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,o=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),h=c(a),u=l,k=h["".concat(s,".").concat(u)]||h[u]||d[u]||o;return a?n.createElement(k,r(r({ref:t},p),{},{components:a})):n.createElement(k,r({ref:t},p))}));function u(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var o=a.length,r=new Array(o);r[0]=h;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:l,r[1]=i;for(var c=2;c<o;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},3201:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var n=a(3117),l=(a(7294),a(3905));a(4996);const o={id:"depAndWthd",title:"Deposit and Withdrawal"},r=void 0,i={unversionedId:"depAndWthd",id:"version-1.6/depAndWthd",title:"Deposit and Withdrawal",description:"Deposits and withdrawals comprise a special messaging mechanism between layer 1 (CKB) and layer 2 (Godwoken) that enables the exchange of assets through the transfer function. Users can deposit assets from layer 1 to layer 2, or withdraw assets from layer 2 to layer 1.",source:"@site/versioned_docs/version-1.6/depAndWthd.md",sourceDirName:".",slug:"/depAndWthd",permalink:"/1.6/depAndWthd",draft:!1,tags:[],version:"1.6",frontMatter:{id:"depAndWthd",title:"Deposit and Withdrawal"},sidebar:"sidebar2",previous:{title:"pCKB",permalink:"/1.6/pCKB"},next:{title:"Godwoken-Kicker",permalink:"/1.6/godwokenkicker"}},s={},c=[{value:"Deposit",id:"deposit",level:2},{value:"Custodian Cell",id:"custodian-cell",level:2},{value:"Withdrawal",id:"withdrawal",level:2},{value:"Withdrawal Cell (v1)",id:"withdrawal-cell-v1",level:3},{value:"Legacy Withdrawal Cells in Godwoken v0",id:"legacy-withdrawal-cells-in-godwoken-v0",level:3}],p={toc:c};function d(e){let{components:t,...a}=e;return(0,l.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Deposits and withdrawals comprise a special messaging mechanism between layer 1 (CKB) and layer 2 (Godwoken) that enables the exchange of assets through the transfer function. Users can deposit assets from layer 1 to layer 2, or withdraw assets from layer 2 to layer 1."),(0,l.kt)("h2",{id:"deposit"},"Deposit"),(0,l.kt)("p",null,"When a layer 1 transaction is sent, it creates a deposit request by generating a cell with a special lock, the deposit lock. The block producer will collect these cells and process the deposit requests in the blocks. It will unlock the deposit cells, move the assets under the custodian lock, update the layer 2 state and submit layer 1 transactions in the blocks. The block producer cannot take away these assets, because a layer 1 script verifies these transactions."),(0,l.kt)("p",null,"The deposit cell:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"lock:\n  code_hash:   (the deposit lock's code hash),\n  hash_type:   Type,\n  args: (rollup_type_hash(32 bytes) | DepositLockArgs)\ncapacity: (the amount of CKB to be deposited),\ntype_:  (none or SUDT script)\ndata:   (none or SUDT amount)\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"lock")," field of the deposit cell uses the deposit lock. The first 32 bytes of ",(0,l.kt)("inlineCode",{parentName:"p"},"args")," is a unique value associated with the rollup instance. ",(0,l.kt)("inlineCode",{parentName:"p"},"DepositLockArgs")," indicates the layer 2 account to which the deposit will be made. ",(0,l.kt)("inlineCode",{parentName:"p"},"capacity")," is the total amount of CKB deposited. The ",(0,l.kt)("inlineCode",{parentName:"p"},"type_")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"data")," fields comply with the CKB Simple UDT format. With these fields, users can deposit Simple UDT assets to layer 2."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"table DepositLockArgs {\n    // layer1 lock hash\n    owner_lock_hash: Byte32,\n    layer2_lock: Script,\n    cancel_timeout: Uint64,\n    registry_id: Uint32,\n}\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"DepositLockArgs")," represents the script and ",(0,l.kt)("inlineCode",{parentName:"p"},"registry_id")," of a layer 2 account, which currently supports only the ETH registry. Users can cancel a deposit after the expiration of ",(0,l.kt)("inlineCode",{parentName:"p"},"cancel_timeout"),", which the block producer can use to reject packed deposit cells containing invalid data."),(0,l.kt)("h2",{id:"custodian-cell"},"Custodian Cell"),(0,l.kt)("p",null,"When assets are deposited to layer 2, deposit cells are converted to custodian cells. The custodian lock protects custodian cells and restricts the transfer of assets so users can only make withdrawals."),(0,l.kt)("p",null,"The custodian cell:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"lock:\n  code_hash:    (the custodian lock's code hash),\n  hash_type:    Type,\n  args: (rollup_type_hash(32 bytes) | CustodianLockArgs)\ncapacity:   (the amount of CKB to be deposited),\ntype_:  (none or SUDT script)\ndata:   (none or SUDT amount)\n")),(0,l.kt)("p",null,"The first 32 bytes of ",(0,l.kt)("inlineCode",{parentName:"p"},"args")," are unique values associated with the rollup instance. ",(0,l.kt)("inlineCode",{parentName:"p"},"CustodianLockArgs")," contains deposit information. ",(0,l.kt)("inlineCode",{parentName:"p"},"capacity")," is the amount of CKB to be deposited. The ",(0,l.kt)("inlineCode",{parentName:"p"},"type_")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"data")," fields follow the CKB Simple UDT format."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"table CustodianLockArgs {\n    deposit_block_hash: Byte32,\n    deposit_block_number: Uint64,\n    deposit_lock_args: DepositLockArgs,\n}\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"CustodianLockArgs")," stores the entire deposit information. ",(0,l.kt)("inlineCode",{parentName:"p"},"deposit_lock_args")," is the args from the original deposit cell. ",(0,l.kt)("inlineCode",{parentName:"p"},"deposit_block_hash")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"deposit_block_number")," denote the layer2 block that contains the deposit."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"capacity")," of a cell must cover the cost of the cell. The ",(0,l.kt)("inlineCode",{parentName:"p"},"capacity")," of the deposit cell must also cover its custodian cell, so the minimum deposit capacity that Godwoken allows is as follows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Deposit CKB: 298 CKB"),(0,l.kt)("li",{parentName:"ul"},"Deposit CKB and Simple UDT: 379 CKB")),(0,l.kt)("h2",{id:"withdrawal"},"Withdrawal"),(0,l.kt)("h3",{id:"withdrawal-cell-v1"},"Withdrawal Cell (v1)"),(0,l.kt)("p",null,"With Godwoken v1, users must sign and sent withdrawal requests to the block producer. The block producer will process these requests in the blocks, update the layer2 state, and convert custodian cells to withdrawal cells in layer1 block submission transactions."),(0,l.kt)("p",null,"The withdrawal cell:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"lock:\n  code_hash:    (the withdrawal lock's code hash),\n  hash_type:    Type,\n  args: (rollup_type_hash(32 bytes) | WithdrawalLockArgs (n bytes) | len (4 bytes) | layer1 owner lock (n bytes))\ncapacity:   (the CKB amount to be withdrawn),\ntype_:  (none or SUDT script)\ndata:   (none or SUDT amount)\n")),(0,l.kt)("p",null,"Withdrawal lock guarantees the user can only unlock this cell after ",(0,l.kt)("inlineCode",{parentName:"p"},"finality blocks"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct WithdrawalLockArgs {\n    withdrawal_block_hash: Byte32,\n    withdrawal_block_number: Uint64,\n    account_script_hash: Byte32,\n    // layer1 lock to withdraw after challenge period\n    owner_lock_hash: Byte32,\n}\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"withdrawal_block_hash")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"withdrawal_block_number")," record the layer2 block that includes the withdrawal. ",(0,l.kt)("inlineCode",{parentName:"p"},"account_script_hash")," represents the layer2 account. ",(0,l.kt)("inlineCode",{parentName:"p"},"owner_lock_hash")," represents the layer1 lock that user uses to unlock the cell."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"capacity")," of a cell must cover the cost of the cell, so the minimum withdrawal capacity that Godwoken allows is as follows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Withdrawal CKB: 266 CKB"),(0,l.kt)("li",{parentName:"ul"},"Withdrawal CKB and Simple UDT: 347 CKB")),(0,l.kt)("p",null,"The block producer processes layer-1 withdrawal cells without leaving the user with too much detail. Users simply need to submit a withdrawal request and wait for receiving the assets cell on CKB."),(0,l.kt)("h3",{id:"legacy-withdrawal-cells-in-godwoken-v0"},"Legacy Withdrawal Cells in Godwoken v0"),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"The lagacy withdrawal cells are no longer in use in Godwoken v1.")),(0,l.kt)("p",null,"The withdrawal cell:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"}," lock:\n   code_hash:    (withdrawal lock's code hash),\n   hash_type:    Type,\n   args: (rollup_type_hash(32 bytes) | WithdrawalLockArgsV0 (n bytes) | owner lock len (optional) | owner lock (optional) | withdrawal_to_v1 flag byte (optional)\n capacity:   (CKB amount),\n type_:  (none or SUDT script)\n data:   (none or SUDT amount)\n")),(0,l.kt)("p",null,"Withdrawal lock guarantees the cell can only be unlocked after ",(0,l.kt)("inlineCode",{parentName:"p"},"finality blocks"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"// --- withdrawal lock ---\n// a rollup_type_hash exists before this args, to make args friendly to prefix search\nstruct WithdrawalLockArgsV0 {\n    account_script_hash: Byte32,\n    withdrawal_block_hash: Byte32,\n    withdrawal_block_number: Uint64,\n    // buyer can pay sell_amount token to unlock\n    sudt_script_hash: Byte32,\n    sell_amount: Uint128,\n    sell_capacity: Uint64,\n    // layer1 lock to withdraw after challenge period\n    owner_lock_hash: Byte32,\n    // layer1 lock to receive the payment, must exists on the chain\n    payment_lock_hash: Byte32,\n }\n")),(0,l.kt)("hr",null),(0,l.kt)("p",null,"We have ",(0,l.kt)("strong",{parentName:"p"},"Optional")," fields in the withdrawal cell's args:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"owner lock"),": a user submits a withdrawal request with an owner lock structure. The block producer will generate withdrawal cells with the ",(0,l.kt)("inlineCode",{parentName:"p"},"owner lock")," field in the args, and will automatically unlock these cells when finalized. The use does not need to manually unlock layer-1 withdrawal cells.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"withdrawal_to_v1"),': functions only if the "owner lock" exists. If ',(0,l.kt)("inlineCode",{parentName:"p"},"withdrawal_to_v1")," exists and the value is ",(0,l.kt)("inlineCode",{parentName:"p"},"1"),", the withdrawal is a fast withdrawal to Godwoken v1. Fast withdrawal from Godwoken v0 to v1 can be instantly processed, and the assets will be migrated to Godwoken v1.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"manually withdrawl")," - if ",(0,l.kt)("inlineCode",{parentName:"p"},"owner lock")," ",(0,l.kt)("strong",{parentName:"p"},"does not exist"),", the user must manually unlock the legacy withdrawal cell when finalized. And, the user must provide an input cell in the unlocking transaction with a ",(0,l.kt)("inlineCode",{parentName:"p"},"lock hash")," that equals to the ",(0,l.kt)("inlineCode",{parentName:"p"},"owner_lock_hash")," of the withdrawal lock args."))))}d.isMDXComponent=!0}}]);